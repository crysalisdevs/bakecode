import '../bakecode-jobs.dart';
import 'package:meta/meta.dart';

/// A connectable entity
abstract class Node {
  final _awaits = <Node>[];

  /// All the output connections from the instance node.
  final _next = <Node>[];

  /// [Node]s that have forward connection from the instance node.
  ///
  /// *Example:*
  /// ```dart
  /// A.connectTo(B);
  /// A.connectTo(C);
  ///
  /// print(A.next);
  /// ```
  /// Output: `[B, C]`
  Iterable<Node> get next => _next;

  /// Whether the instance node is further connected to another node.
  ///
  /// *Example:*
  /// ```dart
  /// A.connectTo(B);
  ///
  /// // will have:
  /// A.hasNext == true;
  /// B.hasNext == false;
  /// ```
  bool get hasNext => _next.isEmpty == false;

  /// Recursively finds the end nodes for the instance node.
  ///
  /// **Note:** Returned iterable may contain duplicates of a same node, and
  /// can be removed by
  /// ```dart
  /// ...endsAt.toSet();
  /// ```
  ///
  /// If no node is there in [next], the instance node is returned.
  ///
  /// *Example:*
  /// ```dart
  /// var flow = Flow.startFrom(A
  ///   ..connectToAll(
  ///     [
  ///       B..connectTo(E),
  ///       C..connectTo(E),
  ///       D,
  ///     ],
  ///   ));
  ///
  /// print(flow.endsAt);
  /// print(flow.endsAt.toSet());
  /// ```
  ///
  /// *Output:*
  /// ```dart
  /// [D, E, E]
  /// {D, E}
  /// ```
  Iterable<Node> get endsAt => (hasNext
      ? _next.map((n) => n.endsAt).reduce((a, b) => a.followedBy(b))
      : [this]);

  /// Updates the input state for [source] w/ the [context].
  ///
  /// If after updating, [isReady] evaluates to true, [onReady] is invoked w/
  /// the provided [context].
  void _updateInputState(Node source, FlowContext context) {
    _awaits.remove(source);

    if (isReady) {
      onReady(context);
    }
  }

  /// Whether every input nodes have finished and is ready to run.
  ///
  /// Evaluates to true if there are no nodes connected to the instance node,
  /// pending to finish.
  bool get isReady => _awaits.isEmpty;

  /// Connects the instance node to the [destination] node.
  ///
  /// The connection made will be a **forward connection**. i.e.,
  /// ```dart
  /// A.connectTo(B);
  /// ```
  /// makes a forward connection from node `A` to node `B`. Or in other words
  /// `B`'s [onReady] will be invoked only after `A`'s [completeWith] is
  /// invoked.
  ///
  /// The [destination] node will start awaiting for the instance node to be
  /// completed w/ a valid [FlowContext] for it's [onReady] to be triggered.
  void connectTo(Node destination) => _next.add(destination.._awaits.add(this));

  /// Connects the instance to every node in [destinations].
  ///
  /// The [destination] node will start awaiting for the instance node to be
  /// completed w/ a valid [FlowContext] for it's [onReady] to be triggered.
  void connectToAll(List<Node> destinations) => destinations.forEach(connectTo);

  /// Completes the Node instance with [context] and informs every nodes in
  /// [next] about the updated [context].
  ///
  /// This method **must** be called after this Node's work so that nodes
  /// awaiting for this node to complete can know when completed.
  void completeWith(FlowContext context) =>
      next.forEach((Node) => Node._updateInputState(this, context));

  /// The function that will be invoked once every connected to the instance
  /// node complete, i.e., when [isReady] evaluates to true.
  ///
  /// This method invokes [run] and then [completeWith] the updated [context] to
  /// finish the node's work.
  @nonVirtual
  @protected
  void onReady(FlowContext context) async {
    await run(context);
    completeWith(context);
  }

  /// Executed by [onReady] when [isReady] evaluates to true.
  ///
  /// [context] shall be the [FlowContext] generated by [Flow.start].
  ///
  /// Make sure all updates to context are reflected on the [context] using
  /// [FlowContext.set] or [FlowContext.merge] for nested flow executions.
  @protected
  Future<void> run(FlowContext context);
}
